<html><body bgcolor="#000000" text="#ffffff"><table><tr><td colspan="2"><h3>Problem Statement</h3></td></tr><tr><td>&#160;&#160;&#160;&#160;</td><td><p>
<b>N</b> robots are waiting in a line at a robot repair facility.
The robots are numbered from 0 to <b>N</b>-1 in the order in which they are waiting.
</p>
<p>
Each of the robots has one of <b>M</b> possible problems.
The problems are numbered from 0 to <b>M</b>-1.
The problem of robot i is P[i].
</p>
<br></br>
<p>
If two or more consecutive robots have the same problem, the workers at the repair facility are happy because they can use the same equipment and thus there are no unnecessary overheads.
</p>
<p>
At some point during the repairs you would like to have at least <b>K</b> consecutive robots that all have the same problem.
In order to reach this goal, you can send an arbitrary subset of robots home.
(The robots that remain waiting will still wait in the same relative order.)
</p>
<p>
Find out whether your goal is reachable.
If it isn't, return -1.
If it is, return the smallest number of robots that need to be sent home.
</p>
<br></br>
<p>
In order to keep the input size small, only a prefix of the array P is given, the rest is generated pseudorandomly.
Please use the code or pseudocode below to generate P.
</p>
<pre>

Pseudocode:

P = an empty array of length N

L = length(Pprefix)
for i = 0 to L-1:
    P[i] = Pprefix[i]

state = seed
for i = L to N-1:
    state = (state * 1103515245 + 12345) modulo 2^31
    P[i] = (state div 16) modulo M

------------------------------------------------------

Java:

int[] P = new int[N];

int L = Pprefix.length;
for (int i=0; i&lt;L; ++i) P[i] = Pprefix[i];

long state = seed;
for (int i=L; i&lt;N; ++i) {
    state = (state * 1103515245 + 12345) % (1L &lt;&lt; 31);
    P[i] = (int)((state / 16) % M);
}

------------------------------------------------------

C++:

vector&lt;int&gt; P(N);

int L = Pprefix.size();
for (int i=0; i&lt;L; ++i) P[i] = Pprefix[i];

long long state = seed;
for (int i=L; i&lt;N; ++i) {
    state = (state * 1103515245 + 12345) % (1LL &lt;&lt; 31);
    P[i] = (state / 16) % M;
}

</pre></td></tr><tr><td colspan="2"><h3>Definition</h3></td></tr><tr><td>&#160;&#160;&#160;&#160;</td><td><table><tr><td>Class:</td><td>ConstantSegment</td></tr><tr><td>Method:</td><td>sendSomeHome</td></tr><tr><td>Parameters:</td><td>int, int, int, vector &lt;int&gt;, int</td></tr><tr><td>Returns:</td><td>int</td></tr><tr><td>Method signature:</td><td>int sendSomeHome(int N, int K, int M, vector &lt;int&gt; Pprefix, int seed)</td></tr><tr><td colspan="2">(be sure your method is public)</td></tr></table></td></tr><tr><td colspan="2"><h3>Limits</h3></td></tr><tr><td>&#160;&#160;&#160;&#160;</td><td><table><tr><td>Time limit (s):</td><td>2.000</td></tr><tr><td>Memory limit (MB):</td><td>256</td></tr></table></td></tr><tr><td colspan="2"><h3>Notes</h3></td></tr><tr><td align="center" valign="top">-</td><td>The reference solution does not depend on the input being pseudorandom, it would correctly solve any input of the given size.</td></tr><tr><td colspan="2"><h3>Constraints</h3></td></tr><tr><td align="center" valign="top">-</td><td><b>N</b> will be between 1 and 200,000, inclusive.</td></tr><tr><td align="center" valign="top">-</td><td><b>K</b> will be between 1 and <b>N</b>, inclusive.</td></tr><tr><td align="center" valign="top">-</td><td><b>M</b> will be between 1 and 10^6, inclusive.</td></tr><tr><td align="center" valign="top">-</td><td><b>Pprefix</b> will have between 0 and min(<b>N</b>, 200) elements, inclusive.</td></tr><tr><td align="center" valign="top">-</td><td>Each element of <b>Pprefix</b> will be between 0 and <b>M</b>-1, inclusive.</td></tr><tr><td align="center" valign="top">-</td><td><b>seed</b> will be between 0 and 2^31 - 1, inclusive.</td></tr><tr><td colspan="2"><h3>Examples</h3></td></tr><tr><td align="center" nowrap="true">0)</td><td></td></tr><tr><td>&#160;&#160;&#160;&#160;</td><td><table><tr><td><table><tr><td><pre>10</pre></td></tr><tr><td><pre>3</pre></td></tr><tr><td><pre>10</pre></td></tr><tr><td><pre>{1, 4, 3, 3, 3, 3, 2, 0, 3, 9}</pre></td></tr><tr><td><pre>0</pre></td></tr></table></td></tr><tr><td><pre>Returns: 0</pre></td></tr><tr><td><table><tr><td colspan="2">You want to have at least three consecutive robots with the same problem. This is already happening: there are four consecutive robots with problem of type 3.</td></tr></table></td></tr></table></td></tr><tr><td align="center" nowrap="true">1)</td><td></td></tr><tr><td>&#160;&#160;&#160;&#160;</td><td><table><tr><td><table><tr><td><pre>10</pre></td></tr><tr><td><pre>5</pre></td></tr><tr><td><pre>10</pre></td></tr><tr><td><pre>{1, 4, 3, 3, 3, 3, 2, 0, 3, 9}</pre></td></tr><tr><td><pre>0</pre></td></tr></table></td></tr><tr><td><pre>Returns: 2</pre></td></tr><tr><td><table><tr><td colspan="2">In order to have at least five consecutive robots with the same problem, you should send home robots #6 (problem of type 2) and #7 (problem of type 0).</td></tr></table></td></tr></table></td></tr><tr><td align="center" nowrap="true">2)</td><td></td></tr><tr><td>&#160;&#160;&#160;&#160;</td><td><table><tr><td><table><tr><td><pre>10</pre></td></tr><tr><td><pre>6</pre></td></tr><tr><td><pre>10</pre></td></tr><tr><td><pre>{1, 4, 3, 3, 3, 3, 2, 0, 3, 9}</pre></td></tr><tr><td><pre>0</pre></td></tr></table></td></tr><tr><td><pre>Returns: -1</pre></td></tr><tr><td><table><tr><td colspan="2">In this test case it is not possible to have six or more consecutive robots with the same problem.</td></tr></table></td></tr></table></td></tr><tr><td align="center" nowrap="true">3)</td><td></td></tr><tr><td>&#160;&#160;&#160;&#160;</td><td><table><tr><td><table><tr><td><pre>10</pre></td></tr><tr><td><pre>2</pre></td></tr><tr><td><pre>47</pre></td></tr><tr><td><pre>{1, 4, 5, 2, 1, 2, 3, 7, 8, 3}</pre></td></tr><tr><td><pre>4747</pre></td></tr></table></td></tr><tr><td><pre>Returns: 1</pre></td></tr><tr><td><table><tr><td colspan="2">The optimal solution here is to send just one robot home: robot #4 (problem type 1). This creates two consecutive robots with the same problem (type 2).</td></tr></table></td></tr></table></td></tr><tr><td align="center" nowrap="true">4)</td><td></td></tr><tr><td>&#160;&#160;&#160;&#160;</td><td><table><tr><td><table><tr><td><pre>20</pre></td></tr><tr><td><pre>3</pre></td></tr><tr><td><pre>10</pre></td></tr><tr><td><pre>{0, 1, 2, 3, 4}</pre></td></tr><tr><td><pre>123456789</pre></td></tr></table></td></tr><tr><td><pre>Returns: 9</pre></td></tr><tr><td><table><tr><td colspan="2"><p>
The array P you should have generated is {0, 1, 2, 3, 4, 0, 5, 7, 1, 3, 5, 4, 0, 6, 3, 7, 2, 4, 6, 5}. 
</p>
<p>
If you wrote your own code to generate P, please watch out for integer overflow when calculating new values of the variable "state".
</p></td></tr></table></td></tr></table></td></tr></table><p>This problem statement is the exclusive and proprietary property of TopCoder, Inc.  Any unauthorized use or reproduction of this information without the prior written consent of TopCoder, Inc. is strictly prohibited.  (c)2003, TopCoder, Inc.  All rights reserved.  </p></body></html>