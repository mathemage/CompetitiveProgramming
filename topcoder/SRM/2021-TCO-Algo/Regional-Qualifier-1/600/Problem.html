<html><body bgcolor="#000000" text="#ffffff"><table><tr><td colspan="2"><h3>Problem Statement</h3></td></tr><tr><td>&#160;&#160;&#160;&#160;</td><td><p>
Given is an undirected tree with <b>N</b> vertices.
As usual, vertices are numbered 0 to <b>N</b>-1.
</p>
<br></br>
<p>
We are going to place some tokens into the vertices of the tree. All tokens are identical. Arbitrarily many tokens can be placed into the same vertex.
</p>
<p>
Once we are done, our opponent will have the option to move the tokens.
In order to make a move, the opponent must always do the following:
</p>
<ol>
<li>the opponent has to select two tokens that are in the same vertex of the tree,</li>
<li>they have to remove one of them (as payment for the move)</li>
<li>then, they may move the other token along an edge of the tree to a different vertex.</li>
</ol>
<p>
The opponent may make as many moves as they like, anywhere where moves can be performed.
Each token may be moved arbitrarily many times.
</p>
<br></br>
<p>
We want to make sure that vertex <b>G</b> remains empty, regardless of what our opponent does.
What is the maximum total number of tokens we can place onto the tree?
Compute this value and return the remainder it gives modulo 1,000,000,007.
</p>
<br></br>
<p>
In order to keep the input small, the tree is generated pseudorandomly using the following pseudocode:
</p>
<pre>

state = seed
for i = 1 to N-1:
    state = (state * 1103515245 + 12345) modulo 2^31
    tmp = (state / 1000) modulo L
    p = max(0, i-1-tmp)

    add a tree edge that connects vertices i and p
</pre></td></tr><tr><td colspan="2"><h3>Definition</h3></td></tr><tr><td>&#160;&#160;&#160;&#160;</td><td><table><tr><td>Class:</td><td>TreeTokens</td></tr><tr><td>Method:</td><td>placeMax</td></tr><tr><td>Parameters:</td><td>int, int, int, int</td></tr><tr><td>Returns:</td><td>int</td></tr><tr><td>Method signature:</td><td>int placeMax(int N, int G, int L, int seed)</td></tr><tr><td colspan="2">(be sure your method is public)</td></tr></table></td></tr><tr><td colspan="2"><h3>Limits</h3></td></tr><tr><td>&#160;&#160;&#160;&#160;</td><td><table><tr><td>Time limit (s):</td><td>2.000</td></tr><tr><td>Memory limit (MB):</td><td>256</td></tr><tr><td>Stack limit (MB):</td><td>256</td></tr></table></td></tr><tr><td colspan="2"><h3>Notes</h3></td></tr><tr><td align="center" valign="top">-</td><td>The reference solution does not depend on the input being pseudorandom.</td></tr><tr><td colspan="2"><h3>Constraints</h3></td></tr><tr><td align="center" valign="top">-</td><td><b>N</b> will be between 1 and 100,000, inclusive.</td></tr><tr><td align="center" valign="top">-</td><td><b>G</b> will be between 0 and <b>N</b>-1, inclusive.</td></tr><tr><td align="center" valign="top">-</td><td><b>L</b> will be between 1 and 10^7, inclusive.</td></tr><tr><td align="center" valign="top">-</td><td><b>seed</b> will be between 0 and 2^31 - 1, inclusive.</td></tr><tr><td colspan="2"><h3>Examples</h3></td></tr><tr><td align="center" nowrap="true">0)</td><td></td></tr><tr><td>&#160;&#160;&#160;&#160;</td><td><table><tr><td><table><tr><td><pre>5</pre></td></tr><tr><td><pre>0</pre></td></tr><tr><td><pre>1000000</pre></td></tr><tr><td><pre>1234567</pre></td></tr></table></td></tr><tr><td><pre>Returns: 4</pre></td></tr><tr><td><table><tr><td colspan="2"><p>
The tree consists of the edges 0-1, 0-2, 0-3, and 0-4.
</p>
<p>
We want to prevent our opponent from getting a token onto vertex 0.
</p>
<p>
The best we can do is to place one token onto each of the other four vertices.
This way the opponent cannot make any valid move.
</p></td></tr></table></td></tr></table></td></tr><tr><td align="center" nowrap="true">1)</td><td></td></tr><tr><td>&#160;&#160;&#160;&#160;</td><td><table><tr><td><table><tr><td><pre>5</pre></td></tr><tr><td><pre>4</pre></td></tr><tr><td><pre>1</pre></td></tr><tr><td><pre>1234567</pre></td></tr></table></td></tr><tr><td><pre>Returns: 15</pre></td></tr><tr><td><table><tr><td colspan="2"><p>
The tree consists of the edges 0-1, 1-2, 2-3, and 3-4.
</p>
<p>
We want to prevent our opponent from getting a token onto vertex 4.
</p>
<p>
The best we can do is to take 15 tokens and place all of them onto vertex 0.
The opponent will be able to do some moves, but they won't be able to get a token onto vertex 4.
</p>
<p>
Regardless of how we distribute 16 (or more) tokens, the opponent will always have a way to get some token onto vertex 4.
</p></td></tr></table></td></tr></table></td></tr><tr><td align="center" nowrap="true">2)</td><td></td></tr><tr><td>&#160;&#160;&#160;&#160;</td><td><table><tr><td><table><tr><td><pre>4</pre></td></tr><tr><td><pre>0</pre></td></tr><tr><td><pre>2</pre></td></tr><tr><td><pre>4742</pre></td></tr></table></td></tr><tr><td><pre>Returns: 4</pre></td></tr><tr><td><table><tr><td colspan="2"><p>
The intermediate values of the variable "state" are 1599137607, 601115508, 1075423389. (Watch out for integer overflows.)
</p>
<p>
The generated tree edges are 1-0, 2-0, and 3-1.
</p></td></tr></table></td></tr></table></td></tr><tr><td align="center" nowrap="true">3)</td><td></td></tr><tr><td>&#160;&#160;&#160;&#160;</td><td><table><tr><td><table><tr><td><pre>7</pre></td></tr><tr><td><pre>5</pre></td></tr><tr><td><pre>3</pre></td></tr><tr><td><pre>47</pre></td></tr></table></td></tr><tr><td><pre>Returns: 17</pre></td></tr><tr><td><table><tr><td colspan="2"><p>
Edges: 0-1, 0-2, 0-3, 3-4, 4-5, 3-6.
</p>
</td></tr></table></td></tr></table></td></tr></table><p>This problem statement is the exclusive and proprietary property of TopCoder, Inc.  Any unauthorized use or reproduction of this information without the prior written consent of TopCoder, Inc. is strictly prohibited.  (c)2003, TopCoder, Inc.  All rights reserved.  </p></body></html>